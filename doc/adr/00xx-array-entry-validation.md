# 15. Heterogeneous array validation

Date: 2024-10-18

## Status

## Context

Given the following array flow to save an entry:

```
               /-a-> page2a (wert: number, year: yearInPast)
page1(art: a|b)
               \-b-> page2b (owner: me|you, year: yearInFuture)
```

We would currently describe this using a flat, partial schema that matches any entry:

```typescript
const entrySchema = z
  .object({
    art: z.enum(["a", "b"]),
    wert: z.number(),
    owner: z.enum(["me", "you"]),
    year: yearInPast.or(yearInFuture),
  })
  .partial();

const arraySchema = z.array(entrySchema);
```

Result: Because we have no information on what valid entries look like, we need additional busines logic when validating entries. Currently this is done via a array-specific `doneFunction()`:

```typescript
function entryDone(entry: UserData[array][0]) {
  return (
    userData.year !== undefined &&
    ((userData.art === "a" && userData.wert !== undefined) ||
      (userData.art === "b" && userData.owner !== undefined))
  );
}

function arrayDone(userData: UserData) {
  return userData.entries !== undefined && userData.entries.every(entryDone);
}
```

Note: We don't need to validate each field schema, because this is already done on saving. We only need to verify the completeness of each entry.

Downsides:

- Additional business logic (mental load, possibility for bugs, ...)
- Entry fields with same name but different schema (like `year` in the example above) are not validated properly
- Testing overhead of done functions

### Alternatives

#### schema.refine()

Replacing the `arrayDone()` with a `arraySchema.refine()` would move the validation logic semantically closer to the schema definition:

```typescript
const arraySchema = z.array(entrySchema).refine((entry) => {
  return (
    entry.year !== undefined &&
    ((entry.art === "a" && entry.wert !== undefined) ||
      (entry.art === "b" && entry.owner !== undefined))
  );
});

function arrayDone(userData: UserData) {
  return arraySchema.safeParse(userData.array).success;
}
```

While this would reduce mental load, the downsides still exist.

#### Explicit entry schemas

Another proposal would be typing the specific entries schemas of an array as a discriminated union:

```typescript
const entryA = z.object({
  art: z.literal("a"),
  wert: z.number(),
  year: yearInPast,
});

const entryB = z.object({
  art: z.literal("b"),
  owner: z.enum(["me", "you"]),
  year: yearInFuture,
});

z.union();
z.discriminatedUnion("art", [entryA, entryB]);

const arraySchema = z.array(entryA.or(entryB));
```

This would replace all done functions by `arraySchema.parse(userData.array)` but:

There is now no schema that can be used to validate the input on a single page (like `const artSchema = z.enum(["a", "b"])`). This is needed both for front-end as well as back-end validation!

This schema might be generated by mapping over each entry schema and combining same-named properties.

## Proposal: Generated entry schemas

If `ADR13 Field Schemas in app` is accepted, we can auto-generate the entry schemas by traversing the flow:

```typescript
const pages = {
  page1: { art: z.enum(["a", "b"]) },
  page2a: { wert: z.number(), year: yearInPast },
  page2b: { owner: z.enum(["me", "you"]), year: yearInFuture },
};

// Generate entry schemas:
// page1 -> page2a ==>
const page1page2aSchema = {
  art: z.literal("a"),
  wert: z.number(),
  year: yearInPast,
};

// page1 -> page2b ==>
const page1page2bSchema = {
  art: z.literal("b"),
  owner: z.enum(["me", "you"]),
  year: yearInFuture,
};

// generated arraySchema:
const arraySchema = z.array([page1page2aSchema.or(page1page2bSchema)]);
```

This allows both easy access to field schemas (`pages.page1.art`) but also easy validation of the array (`arraySchema.parse(userData.array)`).

Bonus: We might be able to even use this for full subflows (`persoenlicheDatenSchema.parse(userData)`), which would mean the removal of ALL done functions!

## Consequences
