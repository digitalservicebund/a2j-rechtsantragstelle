import partition from "lodash/partition";
import type { ProzesskostenhilfePDF } from "data/pdf/prozesskostenhilfe/prozesskostenhilfe.generated";
import { eigentuemerMapping } from "~/domains/shared/services/pdf/eigentumHelpers";
import type { AttachmentEntries } from "~/services/pdf/attachment";
import { SEE_IN_ATTACHMENT_DESCRIPTION } from "~/services/pdf/attachment";
import type { PkhPdfFillFunction } from "../types";
import type z from "zod";
import type {
  sonstigeZahlungArraySchema,
  ratenZahlungArraySchema,
  versicherungenArraySchema,
} from "~/domains/prozesskostenhilfe/formular/finanzielleAngaben/ausgaben/pages";

type Ratenzahlung = z.infer<typeof ratenZahlungArraySchema.element>;
type SonstigeAusgabe = z.infer<typeof sonstigeZahlungArraySchema.element>;
type Versicherung = z.infer<typeof versicherungenArraySchema.element>;

type ZahlungWithDescription = {
  description: string;
  restschuld?: string;
  gesamtbelastung?: string;
  betragEigenerAnteil?: string;
};

const versicherungMapping = {
  haftpflichtversicherung: "Haftpflichtversicherung",
  hausratsversicherung: "Hausratsversicherung",
  kfzVersicherung: "KFZ-Versicherung",
  privateKrankenzusatzversicherung: "Private Krankenzusatzversicherung",
  unfallversicherung: "Unfallversicherung",
  sonstige: "Sonstige",
} as const;

const ZAHLUNGSVERPFLICHTUNG_DESCRIPTION_LINE_LENGTH = 41;

const formatDate = (date?: {
  day: string;
  month: string;
  year: string;
}): string | undefined =>
  date ? `${date.day}.${date.month}.${date.year}` : undefined;

const mapVersicherungsArt = (versicherung: Versicherung) =>
  versicherung.art === "sonstige"
    ? versicherung.sonstigeArt
    : versicherungMapping[versicherung.art];

const mapRatenzahlungAndSonstigeAusgabeToZahlungsverpflichtung = (
  ratenzahlungOrSonstigeAusgabe: Ratenzahlung | SonstigeAusgabe,
) => ({
  description:
    `${ratenzahlungOrSonstigeAusgabe.art}, ${ratenzahlungOrSonstigeAusgabe.zahlungsempfaenger}` +
    ("laufzeitende" in ratenzahlungOrSonstigeAusgabe
      ? `, bis ${formatDate(ratenzahlungOrSonstigeAusgabe.laufzeitende)}`
      : ""),
  restschuld:
    "restschuld" in ratenzahlungOrSonstigeAusgabe
      ? ratenzahlungOrSonstigeAusgabe.restschuld
      : undefined,
  gesamtbelastung: ratenzahlungOrSonstigeAusgabe.betragGesamt,
  betragEigenerAnteil:
    "betragEigenerAnteil" in ratenzahlungOrSonstigeAusgabe
      ? ratenzahlungOrSonstigeAusgabe.betragEigenerAnteil
      : undefined,
});

const pushVersicherungenToAttachment = (
  attachment: AttachmentEntries,
  versicherungen: Versicherung[],
) => {
  attachment.push({ title: "Versicherungen", level: "h3" });
  versicherungen.forEach((versicherung, index) => {
    attachment.push(
      { title: `Versicherung ${index + 1}`, level: "h4" },
      { title: "Art", text: mapVersicherungsArt(versicherung) },
      { title: "Beitrag", text: `${versicherung.beitrag} € / Monat` },
    );
  });
};

const pushRatenzahlungenAndSonstigeAusgabenToAttachment = (
  attachment: AttachmentEntries,
  ratenzahlungenAndSonstigeAusgaben: Array<Ratenzahlung | SonstigeAusgabe>,
) => {
  attachment.push({
    title: "Sonstige Zahlungsverpflichtungen",
    level: "h2",
  });
  ratenzahlungenAndSonstigeAusgaben.forEach((zahlung) => {
    attachment.push(
      { level: "h3", title: zahlung.art ?? "" },
      {
        title: "Zahlungspflichtiger",
        text: eigentuemerMapping[zahlung.zahlungspflichtiger],
      },
      { title: "Zahlungsempfänger", text: zahlung.zahlungsempfaenger },
      {
        title: "Gesamtbelastung monatlich",
        text: zahlung.betragGesamt,
      },
    );
    if (zahlung.zahlungspflichtiger !== "myself") {
      attachment.push({
        title: "Eigenbelastung monatlich",
        text: zahlung.betragEigenerAnteil,
      });
    }
    if ("restschuld" in zahlung) {
      attachment.push({
        title: "Restschuld in EUR",
        text: zahlung.restschuld,
      });
    }
    if ("laufzeitende" in zahlung)
      attachment.push({
        title: "Laufzeitende",
        text: formatDate(zahlung.laufzeitende),
      });
  });
};

const fillPdfValues = (
  pdfValues: ProzesskostenhilfePDF,
  zahlungShort: ZahlungWithDescription[],
  zahlungenWithDescription: ZahlungWithDescription[],
) => {
  // There are 3 rows to fill in the PDF, keys are generated by appending the index
  for (let i = 0; i < 3 && i < zahlungShort.length; i++) {
    const entry = zahlungenWithDescription[i];
    const index = (i + 1) as 1 | 2 | 3;
    pdfValues[`sonstigeZahlungsverpflichtungen${index}`].value =
      entry.description;
    pdfValues[`restschuldinEurosonstigeZahlungsverpflichtungen${index}`].value =
      "restschuld" in entry ? entry.restschuld : undefined;
    pdfValues[`gesamtbelastungmtl${index}`].value =
      "gesamtbelastung" in entry ? entry.gesamtbelastung : "";
    pdfValues[
      `ichalleinzahledavonsonstigeZahlungsverpflichtungen${index}`
    ].value = entry.betragEigenerAnteil;
  }
};

export const fillZahlungsverpflichtungen: PkhPdfFillFunction = ({
  userData,
  pdfValues,
}) => {
  const versicherungen = userData.versicherungen ?? [];
  const ratenzahlungenAndSonstigeAusgaben = [
    ...(userData.ratenzahlungen ?? []),
    ...(userData.sonstigeAusgaben ?? []),
  ];

  const zahlungenWithDescription = [
    ...ratenzahlungenAndSonstigeAusgaben.map(
      mapRatenzahlungAndSonstigeAusgabeToZahlungsverpflichtung,
    ),
    ...versicherungen.map((versicherung) => ({
      description: mapVersicherungsArt(versicherung),
      gesamtbelastung: versicherung.beitrag,
    })),
  ];

  const [zahlungLong, zahlungShort] = partition(
    zahlungenWithDescription,
    (zahlung) =>
      zahlung.description.length >
      ZAHLUNGSVERPFLICHTUNG_DESCRIPTION_LINE_LENGTH,
  );

  const needAttachement = zahlungShort.length > 3 || zahlungLong.length > 0;

  if (needAttachement) {
    pdfValues.sonstigeZahlungsverpflichtungen1.value =
      SEE_IN_ATTACHMENT_DESCRIPTION;

    const attachment: AttachmentEntries = [];

    if (ratenzahlungenAndSonstigeAusgaben) {
      pushRatenzahlungenAndSonstigeAusgabenToAttachment(
        attachment,
        ratenzahlungenAndSonstigeAusgaben,
      );
    }

    if (versicherungen) {
      pushVersicherungenToAttachment(attachment, versicherungen);
    }
    return { pdfValues, attachment };
  }

  fillPdfValues(pdfValues, zahlungShort, zahlungenWithDescription);

  return { pdfValues };
};
