import { parseFormData } from "@mjackson/form-data-parser";
import { validationError } from "@rvf/react-router";
import type { ActionFunctionArgs, LoaderFunctionArgs } from "react-router";
import { data, redirectDocument } from "react-router";
import { parsePathname } from "~/domains/flowIds";
import { retrieveContentData } from "~/services/flow/formular/contentData/retrieveContentData";
import { setUserVisitedValidationPage } from "~/services/flow/formular/contentData/setUserVisitedValidationPage";
import { isFileUploadOrDeleteAction } from "~/services/flow/formular/fileUpload/isFileUploadOrDeleteAction";
import { getUserDataAndFlow } from "~/services/flow/userDataAndFlow/getUserDataAndFlow";
import { flowDestination } from "~/services/flow/userFlowAction/flowDestination";
import { postValidationFlowAction } from "~/services/flow/userFlowAction/postValidationFlowAction";
import { validateFormUserData } from "~/services/flow/userFlowAction/validateFormUserData";
import { logWarning } from "~/services/logging";
import { validatedSession } from "~/services/security/csrf/validatedSession.server";
import { getSessionManager, updateSession } from "~/services/session.server";
import { updateMainSession } from "~/services/session.server/updateSessionInHeader";
import { z } from "zod";
import { StrapiSummaryOverviewSectionSchema } from "~/services/cms/models/content/StrapiSummaryOverviewSection";
import {
  deleteUserFile,
  uploadUserFile,
} from "~/services/upload/fileUploadHelpers.server";

type StrapiSummaryOverviewSection = z.infer<typeof StrapiSummaryOverviewSectionSchema>;
import { FIFTEEN_MB_IN_BYTES } from "~/services/validation/pdfFileSchema";
export { FormFlowPage as default } from "~/routes/shared/components/FormFlowPage";
import { shouldShowReportProblem } from "../../components/reportProblem/showReportProblem";
import { generateAutomaticSummary, generateSummaryFromUserData } from "~/services/summary/autoGenerateSummary";
import { getFormQuestionsForFields } from "~/services/summary/getFormQuestions";

export const loader = async ({ params, request }: LoaderFunctionArgs) => {
  const resultUserAndFlow = await getUserDataAndFlow(request);

  if (resultUserAndFlow.isErr) {
    return redirectDocument(resultUserAndFlow.error.redirectTo);
  }

  const {
    userData,
    flow: {
      id: flowId,
      controller: flowController,
      validFlowPaths,
      userVisitedValidationPage,
      useStepper,
    },
    page: { stepId, arrayIndexes },
    migration,
    emailCaptureConsent,
  } = resultUserAndFlow.value;

  const { pathname } = new URL(request.url);
  const cookieHeader = request.headers.get("Cookie");

  const [contentData, { headers, csrf }] = await Promise.all([
    retrieveContentData(pathname, params, userData, migration.userData),
    updateMainSession({ cookieHeader, flowId, stepId }),
    setUserVisitedValidationPage(
      flowController.getMeta(stepId)?.triggerValidation,
      flowId,
      cookieHeader,
    ),
  ]);

  const translations = contentData.getTranslations();
  const navProps = contentData.getNavProps(flowController, stepId, useStepper);
  const cmsContent = contentData.getCMSContent();
  const formElements = contentData.getFormElements();
  const meta = contentData.getMeta();
  const arraySummaryData = contentData.arraySummaryData(flowController);
  const stepData = contentData.getStepData();
  const buttonNavigationProps = contentData.getButtonNavigation(
    flowController,
    pathname,
    stepId,
    arrayIndexes,
  );

  // Add auto-generated summary for zusammenfassung steps
  let autoGeneratedSections: StrapiSummaryOverviewSection[] = [];
  if (stepId.includes("zusammenfassung")) {
    console.log("ðŸ” Debug zusammenfassung step:");
    console.log("- stepId:", stepId);
    console.log("- userData keys:", Object.keys(userData));
    console.log("- formElements length:", formElements.length);
    console.log("- formElements sample:", formElements.slice(0, 2));
    console.log("- translations keys:", Object.keys(translations).slice(0, 10));

    // Test the form questions service
    console.log("ðŸ§ª Testing form questions service...");
    const userDataFields = Object.keys(userData).filter(
      key => !['pageData', 'csrf', '_action'].includes(key) && userData[key] !== undefined
    );
    console.log("ðŸ“‹ User data fields to test:", userDataFields.slice(0, 10)); // First 10 fields

    try {
      const fieldQuestions = await getFormQuestionsForFields(userDataFields.slice(0, 5), flowId);
      console.log("â“ Retrieved field questions:", fieldQuestions);
    } catch (questionError) {
      console.error("âŒ Form questions service failed:", questionError);
    }

    try {
      // For zusammenfassung steps, formElements is empty, so we'll generate from userData
      if (formElements.length === 0) {
        console.log("ðŸ“ No form elements, generating from userData directly");
        autoGeneratedSections = await generateSummaryFromUserData(userData, flowId, translations, flowController);
      } else {
        autoGeneratedSections = generateAutomaticSummary(
          userData,
          formElements,
          translations,
        );
      }
      console.log("âœ… autoGeneratedSections:", autoGeneratedSections);
      console.log("ðŸ” validFlowPaths keys:", Object.keys(validFlowPaths));
      console.log("ðŸ” Sample autoGeneratedSection structure:", JSON.stringify(autoGeneratedSections[0], null, 2));
    } catch (error) {
      console.error("âŒ Auto-generation failed:", error);
    }
  }

  return data(
    {
      arraySummaryData,
      userData,
      navigationProps: {
        ...navProps,
        userVisitedValidationPage,
      },
      buttonNavigationProps,
      cmsContent,
      csrf,
      emailCaptureConsent,
      formElements,
      meta,
      migration,
      stepData,
      translations,
      validFlowPaths,
      flowId,
      showReportProblem: shouldShowReportProblem(stepId),
      autoGeneratedSections,
    },
    { headers },
  );
};

export const action = async ({ request }: ActionFunctionArgs) => {
  const resultValidatedSession = await validatedSession(request);
  if (resultValidatedSession.isErr) {
    logWarning(resultValidatedSession.error);
    throw new Response(null, { status: 403 });
  }

  const { pathname } = new URL(request.url);
  const { flowId } = parsePathname(pathname);
  const { getSession, commitSession } = getSessionManager(flowId);
  const cookieHeader = request.headers.get("Cookie");
  const flowSession = await getSession(cookieHeader);
  const formData = await parseFormData(request.clone(), {
    maxFileSize: FIFTEEN_MB_IN_BYTES,
  });
  const formAction = formData.get("_action");

  if (isFileUploadOrDeleteAction(formAction)) {
    const [action, inputName] = formAction.split(".");
    if (action === "fileUpload") {
      const result = await uploadUserFile(
        inputName,
        cookieHeader,
        formData,
        flowSession.data,
        flowId,
        pathname,
      );
      if ("fieldErrors" in result)
        return validationError(result, result.repopulateFields);
      updateSession(flowSession, result.userData);
    } else if (action === "deleteFile") {
      const userData = await deleteUserFile(
        inputName,
        cookieHeader,
        flowSession.data,
        flowId,
      );
      if (userData) {
        updateSession(flowSession, userData, (_, newData) =>
          Array.isArray(newData) ? newData : undefined,
        );
      }
    }
    return data(flowSession.data, {
      headers: { "Set-Cookie": await commitSession(flowSession) },
      status: 200,
    });
  }

  const resultFormUserData = await validateFormUserData(
    formData,
    pathname,
    cookieHeader,
  );

  if (resultFormUserData.isErr) {
    return validationError(
      resultFormUserData.error.error,
      resultFormUserData.error.submittedData,
    );
  }

  updateSession(flowSession, resultFormUserData.value.userData);

  if (resultFormUserData.value.migrationData) {
    updateSession(flowSession, resultFormUserData.value.migrationData);
  }
  await postValidationFlowAction(request, flowSession.data);

  const headers = { "Set-Cookie": await commitSession(flowSession) };
  const destination = flowDestination(pathname, flowSession.data);
  return redirectDocument(destination, { headers });
};
