import type { UserData } from "~/domains/userData";
import type { StrapiFormComponent } from "~/services/cms/models/formElements/StrapiFormComponent";
import type { FlowController } from "~/services/flow/server/buildFlowController";
import type { Translations } from "~/services/translations/getTranslationByKey";
import { z } from "zod";
import { StrapiSummaryOverviewSectionSchema } from "~/services/cms/models/content/StrapiSummaryOverviewSection";

type StrapiSummaryOverviewSection = z.infer<
  typeof StrapiSummaryOverviewSectionSchema
>;
import { extractFormFieldsWithMetadata } from "./formMetadata";
import { getEnhancedFieldLabel } from "./labelEnhancement";
import { isFieldEmpty } from "./formatFieldValue";
import { getFormQuestionsForFields } from "./getFormQuestions";
import type { FlowId } from "~/domains/flowIds";

export type AutoGeneratedSummarySection = {
  sectionId: string;
  navigationTitle: string;
  editStepId: string;
  fields: FormFieldMetadata[];
};

export type FormFieldMetadata = {
  fieldName: string;
  autoGeneratedLabel: string;
  stepId: string;
  componentType: string;
  value: unknown;
  isEmpty: boolean;
};

export function generateAutomaticSummary(
  userData: UserData,
  formComponents: StrapiFormComponent[],
  translations?: Translations,
): StrapiSummaryOverviewSection[] {
  // This function creates a single summary section from the provided form components
  // The caller is responsible for organizing by steps

  // Extract field metadata for all components
  const fieldMetadata = extractFormFieldsWithMetadata(
    userData,
    formComponents,
    "auto-generated", // stepId - will be overridden by caller
    translations,
  );

  // Filter out empty fields
  const nonEmptyFields = fieldMetadata.filter((field) => !field.isEmpty);

  if (nonEmptyFields.length === 0) {
    return [];
  }

  // Create a single summary section
  const section: StrapiSummaryOverviewSection = {
    __component: "page.summary-overview-section",
    id: 1,
    title: {
      __component: "basic.heading",
      text: "Automatically Generated Summary",
      tagName: "h2",
      look: "ds-heading-02-reg",
      id: 1,
    },
    boxes: [
      {
        id: 100,
        title: undefined as any,
        stepId: "auto-generated:summary",
        boxItems: nonEmptyFields.map((field) => ({
          title: field.autoGeneratedLabel,
          inlineItems: [
            {
              field: field.fieldName,
              emptyValuePlaceholder: "Keine Angabe",
            },
          ],
        })),
      },
    ],
  };

  return [section];
}

// Enhanced version that works with flow controller to create sections by step
export function generateSummaryBySteps(
  userData: UserData,
  formComponentsByStep: Map<string, StrapiFormComponent[]>,
  flowController: FlowController,
  translations?: Translations,
): StrapiSummaryOverviewSection[] {
  const stepStates = flowController.stepStates();
  const sections: StrapiSummaryOverviewSection[] = [];
  let sectionCounter = 1;

  for (const stepState of stepStates) {
    const stepComponents = formComponentsByStep.get(stepState.stepId);
    if (!stepComponents || stepComponents.length === 0) {
      continue;
    }

    // Extract field metadata for this step
    const fieldMetadata = extractFormFieldsWithMetadata(
      userData,
      stepComponents,
      stepState.stepId,
      translations,
    );

    // Filter out empty fields
    const nonEmptyFields = fieldMetadata.filter((field) => !field.isEmpty);

    if (nonEmptyFields.length === 0) {
      continue;
    }

    // Use step ID as navigation title with fallback
    const navigationTitle = stepState.stepId || `Schritt ${sectionCounter}`;

    // Create summary section
    const section: StrapiSummaryOverviewSection = {
      __component: "page.summary-overview-section",
      id: sectionCounter,
      title: {
        __component: "basic.heading",
        text: navigationTitle,
        tagName: "h2",
        look: "ds-heading-02-reg",
        id: sectionCounter,
      },
      boxes: [
        {
          id: sectionCounter * 100,
          title: undefined as any,
          stepId: stepState.stepId,
          boxItems: [
            {
              title: undefined as any,
              inlineItems: nonEmptyFields.map((field) => ({
                field: field.fieldName,
                emptyValuePlaceholder: "",
              })),
            },
          ],
        },
      ],
    };

    sections.push(section);
    sectionCounter++;
  }

  return sections;
}

// Alternative function for when there are no form elements (e.g., summary pages)
const EXCLUDED_FIELDS_USERDATA = new Set(["pageData", "csrf", "_action"]);

// Mock form component for fields that don't have actual form components
const createMockFormComponent = (fieldName: string) => ({
  __component: "form-elements.input" as const,
  id: 0,
  name: fieldName,
  type: "text" as const,
  width: "16" as const,
  errorMessages: [],
});

export async function generateSummaryFromUserData(
  userData: UserData,
  flowId: FlowId,
  translations?: Translations,
): Promise<StrapiSummaryOverviewSection[]> {
  // Get all non-excluded field names from userData
  const userDataFields = Object.keys(userData).filter(
    (fieldName) =>
      !EXCLUDED_FIELDS_USERDATA.has(fieldName) &&
      userData[fieldName] !== undefined,
  );

  if (userDataFields.length === 0) {
    return [];
  }

  // Get actual form questions for fields
  const fieldQuestions = await getFormQuestionsForFields(
    userDataFields,
    flowId,
  );

  // Group fields by logical boxes (section -> box -> fields)
  const fieldGroups = groupFieldsByLogicalBoxes(userDataFields);

  const sections: StrapiSummaryOverviewSection[] = [];
  let sectionCounter = 1;

  for (const [sectionName, boxes] of Object.entries(fieldGroups)) {
    const sectionBoxes: Array<{
      id: number;
      title: {
        __component: "basic.heading";
        text: string;
        tagName: "h3";
        look: "ds-heading-03-reg";
        id: number;
      };
      stepId: string;
      boxItems: Array<{
        title: string;
        inlineItems: Array<{
          field: string;
          emptyValuePlaceholder: string;
        }>;
      }>;
    }> = [];

    let boxCounter = 1;
    for (const [boxName, fields] of Object.entries(boxes)) {
      // For "other" section (Weitere Angaben), always show even if empty
      // For other sections, filter out empty fields
      const nonEmptyFields =
        sectionName === "other"
          ? fields // Show all fields in "other" section, even if empty
          : fields.filter((fieldName) => {
              const value = userData[fieldName];
              return !isFieldEmpty(value, "form-elements.input");
            });

      if (nonEmptyFields.length === 0) {
        continue;
      }

      // Create inline items for this box
      const inlineItems = nonEmptyFields.map((fieldName) => {
        // Use actual form question if available, otherwise fall back to enhanced label
        const question = fieldQuestions[fieldName]?.question;
        let label: string;

        if (question) {
          label = question;
        } else {
          // Fallback to enhanced label system
          const mockComponent = createMockFormComponent(fieldName);
          label = getEnhancedFieldLabel(fieldName, mockComponent, translations);
        }

        return {
          field: fieldName,
          label,
          emptyValuePlaceholder: "",
        };
      });

      // Create box with proper title
      const box = {
        id: sectionCounter * 100 + boxCounter,
        title: {
          __component: "basic.heading" as const,
          text: getBoxDisplayName(boxName),
          tagName: "h3" as const,
          look: "ds-heading-03-reg" as const,
          id: sectionCounter * 100 + boxCounter,
        },
        stepId: `auto-generated:${boxName}`,
        boxItems: inlineItems.map((item) => ({
          title: item.label,
          inlineItems: [
            {
              field: item.field,
              emptyValuePlaceholder:
                item.emptyValuePlaceholder || "Keine Angabe",
            },
          ],
        })),
      };

      sectionBoxes.push(box);
      boxCounter++;
    }

    if (sectionBoxes.length === 0) {
      continue;
    }

    // Create summary section with multiple boxes
    const section: StrapiSummaryOverviewSection = {
      __component: "page.summary-overview-section",
      id: sectionCounter,
      title: {
        __component: "basic.heading",
        text: getGroupDisplayName(sectionName),
        tagName: "h2",
        look: "ds-heading-02-reg",
        id: sectionCounter,
      },
      boxes: sectionBoxes,
    };

    sections.push(section);
    sectionCounter++;
  }

  return sections;
}

function groupFieldsByLogicalBoxes(
  fields: string[],
): Record<string, Record<string, string[]>> {
  // Define field mappings to section -> box -> fields structure
  const fieldMappings: Record<string, { section: string; box: string }> = {
    // Grundvoraussetzungen
    rechtsschutzversicherung: {
      section: "grundvoraussetzungen",
      box: "rechtsschutz",
    },
    wurdeVerklagt: { section: "grundvoraussetzungen", box: "rechtslage" },
    klageEingereicht: { section: "grundvoraussetzungen", box: "rechtslage" },
    hamburgOderBremen: {
      section: "grundvoraussetzungen",
      box: "zustaendigkeit",
    },
    beratungshilfeBeantragt: {
      section: "grundvoraussetzungen",
      box: "vorherige_antraege",
    },
    eigeninitiativeGrundvorraussetzung: {
      section: "grundvoraussetzungen",
      box: "eigeninitiative",
    },
    anwaltskanzlei: { section: "grundvoraussetzungen", box: "anwalt" },

    // Personal data - all in one box
    vorname: { section: "personal", box: "persoenliche_daten" },
    nachname: { section: "personal", box: "persoenliche_daten" },
    geburtsdatum: { section: "personal", box: "persoenliche_daten" },
    plz: { section: "personal", box: "persoenliche_daten" },
    street: { section: "personal", box: "persoenliche_daten" },
    houseNumber: { section: "personal", box: "persoenliche_daten" },
    ort: { section: "personal", box: "persoenliche_daten" },
    telefonnummer: { section: "personal", box: "persoenliche_daten" },

    // Financial - separate into logical boxes like CMS
    staatlicheLeistungen: { section: "financial", box: "laufende_leistungen" },
    erwerbstaetig: { section: "financial", box: "erwerbstaetigkeit" },
    berufsituation: { section: "financial", box: "erwerbstaetigkeit" },
    einkommen: { section: "financial", box: "erwerbstaetigkeit" },
    weitereseinkommen: { section: "financial", box: "weiteres_einkommen" },
    partnerschaft: { section: "financial", box: "familienverhaeltnisse" },
    hasKinder: { section: "financial", box: "familienverhaeltnisse" },
    hasWeitereUnterhaltszahlungen: {
      section: "financial",
      box: "familienverhaeltnisse",
    },
    livingSituation: { section: "financial", box: "wohnsituation" },
    apartmentSizeSqm: { section: "financial", box: "wohnsituation" },
    apartmentPersonCount: { section: "financial", box: "wohnsituation" },
    apartmentCostFull: { section: "financial", box: "wohnsituation" },
    apartmentCostOwnShare: { section: "financial", box: "wohnsituation" },
    hasBankkonto: { section: "financial", box: "vermoegen" },
    hasGeldanlage: { section: "financial", box: "vermoegen" },
    hasKraftfahrzeug: { section: "financial", box: "vermoegen" },
    hasWertsache: { section: "financial", box: "vermoegen" },
    hasGrundeigentum: { section: "financial", box: "vermoegen" },
    hasAusgaben: { section: "financial", box: "ausgaben" },

    // Legal - separate boxes for different aspects
    bereich: { section: "legal", box: "rechtsgebiet" },
    gegenseite: { section: "legal", box: "verfahren" },
    beschreibung: { section: "legal", box: "sachverhalt" },
    ziel: { section: "legal", box: "ziel" },
    eigeninitiativeBeschreibung: {
      section: "legal",
      box: "eigeninitiative_legal",
    },

    // Other
    weitereAngaben: { section: "other", box: "zusaetzliche_angaben" },
  };

  // Group fields by section -> box -> fields
  const groups: Record<string, Record<string, string[]>> = {};

  for (const field of fields) {
    const mapping = fieldMappings[field];
    if (mapping) {
      if (!groups[mapping.section]) {
        groups[mapping.section] = {};
      }
      if (!groups[mapping.section][mapping.box]) {
        groups[mapping.section][mapping.box] = [];
      }
      groups[mapping.section][mapping.box].push(field);
    }
  }

  return groups;
}

function getBoxDisplayName(boxKey: string): string {
  const boxNames: Record<string, string> = {
    // Grundvoraussetzungen
    rechtsschutz: "Rechtsschutzversicherung",
    rechtslage: "Rechtslage",
    zustaendigkeit: "Zuständigkeit",
    vorherige_antraege: "Vorherige Anträge",
    eigeninitiative: "Eigeninitiative",
    anwalt: "Anwaltliche Vertretung",

    // Personal
    persoenliche_daten: "Persönliche Angaben",

    // Financial
    laufende_leistungen: "Laufende Leistung zum Lebensunterhalt",
    erwerbstaetigkeit: "Erwerbstätig",
    weiteres_einkommen: "Weiteres Einkommen",
    familienverhaeltnisse: "Familienverhältnisse",
    wohnsituation: "Wohnsituation",
    vermoegen: "Vermögen",
    ausgaben: "Ausgaben",

    // Legal
    rechtsgebiet: "Rechtsgebiet",
    verfahren: "Verfahren",
    sachverhalt: "Sachverhalt",
    ziel: "Ziel",
    eigeninitiative_legal: "Eigeninitiative",

    // Other
    zusaetzliche_angaben: "Weitere Angaben",
  };

  return boxNames[boxKey] || boxKey;
}

function getGroupDisplayName(groupName: string): string {
  const groupNames: Record<string, string> = {
    grundvoraussetzungen: "Grundvoraussetzungen",
    personal: "Persönliche Angaben",
    financial: "Finanzielle Angaben",
    legal: "Rechtliche Angaben",
    other: "Weitere Angaben",
  };

  return groupNames[groupName] || "Sonstige Angaben";
}
