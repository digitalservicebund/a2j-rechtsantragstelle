import type { UserData } from "~/domains/userData";
import type {
  FlowController,
  StepState,
} from "~/services/flow/server/buildFlowController";
import type { SummaryItem } from "~/components/content/summaryOverview/AutoGeneratedSummary";
import { formatFieldValue } from "./formatFieldValue";
import type { Translations } from "~/services/translations/getTranslationByKey";
import {
  getFormQuestionsForFields,
  createFieldToStepMapping,
} from "./getFormQuestions";
import type { FlowId } from "~/domains/flowIds";
import { fetchAllFormFields } from "~/services/cms/fetchAllFormFields";

const EXCLUDED_FIELDS_USERDATA = new Set(["pageData"]);

function isUserDataFieldEmpty(value: unknown): boolean {
  // Only consider null, undefined, or empty strings as empty
  // All other values (including "no", false, 0) are considered answered
  return value == null || value === "";
}

function getUserDataFieldLabel(
  fieldName: string,
  fieldQuestions: Record<string, { question?: string }>,
): string {
  const question = fieldQuestions[fieldName]?.question;

  if (question) {
    return question;
  }

  return fieldName;
}

export async function generateSummaryFromUserData(
  userData: UserData,
  flowId: FlowId,
  translations?: Translations,
  flowController?: FlowController,
): Promise<SummaryItem[]> {
  const userDataFields = Object.keys(userData).filter(
    (fieldName) =>
      !EXCLUDED_FIELDS_USERDATA.has(fieldName) &&
      userData[fieldName] !== undefined,
  );

  if (userDataFields.length === 0) {
    return [];
  }

  const fieldQuestions = await getFormQuestionsForFields(
    userDataFields,
    flowId,
  );

  const formFieldsMap = await fetchAllFormFields(flowId);
  const fieldToStepMapping = createFieldToStepMapping(formFieldsMap);

  const groupingResult = flowController
    ? groupFieldsByFlowNavigation(
        userDataFields,
        flowId,
        flowController,
        fieldToStepMapping,
        translations,
      )
    : { groups: {}, sectionTitles: {} };

  const sections: SummaryItem[] = [];

  for (const [sectionName, boxes] of Object.entries(groupingResult.groups)) {
    const allFields: { question: string; answer: string; editUrl?: string }[] =
      [];

    for (const [boxName, fields] of Object.entries(boxes)) {
      if (fields.length === 0) {
        continue;
      }

      // Find representative stepId for edit URLs
      const representativeField = fields[0];
      const representativeStepId = fieldToStepMapping[representativeField];

      // Skip boxes that don't have a real stepId
      if (!representativeStepId) {
        console.log(
          `⚠️ Skipping box "${boxName}" - no real stepId found for field "${representativeField}"`,
        );
        continue;
      }

      // Create field items for this box
      for (const fieldName of fields) {
        const value = userData[fieldName];
        const isEmpty = isUserDataFieldEmpty(value);

        const question = getUserDataFieldLabel(fieldName, fieldQuestions);
        const fieldQuestion = fieldQuestions[fieldName];
        const answer = isEmpty
          ? "Keine Angabe"
          : formatFieldValue(value, fieldQuestion?.options);
        const editUrl = representativeStepId
          ? `..${representativeStepId}`
          : undefined;

        allFields.push({ question, answer, editUrl });
      }
    }

    if (allFields.length === 0) {
      continue;
    }

    // Create simplified summary section
    const section: SummaryItem = {
      id: sectionName,
      title:
        groupingResult.sectionTitles[sectionName] ||
        translations?.[sectionName] ||
        sectionName,
      fields: allFields,
    };

    sections.push(section);
  }

  return sections;
}

// Sections to exclude from auto-generated summaries
const EXCLUDED_SECTIONS = new Set([
  "start",
  "abgabe",
  "zusammenfassung",
  "summary",
  "ergebnis",
  "result",
]);

function groupFieldsByFlowNavigation(
  fields: string[],
  _flowId: FlowId,
  flowController: FlowController,
  fieldToStepMapping: Record<string, string>,
  translations?: Translations,
): {
  groups: Record<string, Record<string, string[]>>;
  sectionTitles: Record<string, string>;
} {
  // Get the step hierarchy from flow controller
  const stepStates = flowController.stepStates();

  const stepToSectionMapping = createStepToSectionMapping(stepStates);

  const groups: Record<string, Record<string, string[]>> = {};
  const sectionTitles: Record<string, string> = {};

  for (const field of fields) {
    let stepId = fieldToStepMapping[field];

    if (!stepId) {
      // Look for nested field patterns like "berufart.selbststaendig" -> "/finanzielle-angaben/einkommen/art"
      const nestedFieldMapping = Object.entries(fieldToStepMapping).find(
        ([mappedField]) => mappedField.startsWith(`${field}.`),
      );

      if (nestedFieldMapping) {
        stepId = nestedFieldMapping[1];
        fieldToStepMapping[field] = stepId;
        console.log(
          `Found nested mapping: "${field}" -> "${stepId}" via "${nestedFieldMapping[0]}"`,
        );
      }
    }

    if (!stepId) {
      // Field not found in any step, put it in "other" section
      addFieldToGroup(groups, "other", "zusaetzliche_angaben", field);
      continue;
    }

    // Get the top-level section for this step
    const sectionInfo = getSectionFromStepId(stepId, stepToSectionMapping);
    const sectionKey = sectionInfo.sectionKey.replace(/^\//, "");

    console.log(
      `Field "${field}" -> stepId "${stepId}" -> sectionKey "${sectionKey}" boxKey "${sectionInfo.boxKey}"`,
    );

    if (EXCLUDED_SECTIONS.has(sectionKey)) {
      console.log(`⏭️ Skipping excluded section: ${sectionKey}`);
      continue;
    }

    // Collect the section title from flow controller using translations like navigation does
    if (sectionInfo.sectionTitle && !sectionTitles[sectionKey]) {
      sectionTitles[sectionKey] =
        translations?.[sectionInfo.sectionTitle] ?? sectionInfo.sectionTitle;
    }

    const boxKey = sectionInfo.boxKey ?? "default";
    addFieldToGroup(groups, sectionKey, boxKey, field);
  }

  return { groups, sectionTitles };
}

function createStepToSectionMapping(
  stepStates: StepState[],
): Record<string, { sectionKey: string; sectionTitle: string }> {
  const mapping: Record<string, { sectionKey: string; sectionTitle: string }> =
    {};

  function processStepState(stepState: StepState, parentSectionKey?: string) {
    // If this step has sub-states, it's likely a section header
    if (stepState.subStates && stepState.subStates.length > 0) {
      const sectionKey = stepState.stepId;

      // Map all sub-steps to this section
      for (const subState of stepState.subStates) {
        processStepState(subState, sectionKey);
      }
    } else {
      // This is a leaf step - map it to the parent section
      const sectionKey = parentSectionKey ?? stepState.stepId;
      mapping[stepState.stepId] = {
        sectionKey,
        sectionTitle: parentSectionKey ?? stepState.stepId,
      };
    }
  }

  for (const stepState of stepStates) {
    processStepState(stepState);
  }

  return mapping;
}

function getSectionFromStepId(
  stepId: string,
  stepToSectionMapping: Record<
    string,
    { sectionKey: string; sectionTitle: string }
  >,
): { sectionKey: string; sectionTitle?: string; boxKey?: string } {
  // First try exact match
  const sectionInfo = stepToSectionMapping[stepId];
  if (sectionInfo) {
    return {
      sectionKey: sectionInfo.sectionKey,
      sectionTitle: sectionInfo.sectionTitle,
      boxKey: extractBoxKeyFromStepId(stepId),
    };
  }

  // Try to find a parent section by matching step prefixes
  // For example: "/finanzielle-angaben/partner/partner-einkommen-summe" should match "/finanzielle-angaben"
  for (const [mappedStepId, mappedSectionInfo] of Object.entries(
    stepToSectionMapping,
  )) {
    if (stepId.startsWith(mappedStepId + "/")) {
      return {
        sectionKey: mappedSectionInfo.sectionKey,
        sectionTitle: mappedSectionInfo.sectionTitle,
        boxKey: extractBoxKeyFromStepId(stepId, mappedStepId),
      };
    }
  }

  // Fallback: try to extract section from stepId path
  const pathParts = stepId.split("/").filter(Boolean);
  if (pathParts.length >= 2) {
    return {
      sectionKey: pathParts[0], // First part should be the main section
      boxKey: pathParts[1], // Second part should be the subsection
    };
  }

  return { sectionKey: "other" };
}

function extractBoxKeyFromStepId(
  stepId: string,
  parentStepId?: string,
): string {
  // Extract a meaningful box key from the step ID
  const pathParts = stepId.split("/").filter(Boolean);

  if (parentStepId) {
    // Remove the parent path to get the relative sub-path
    const parentParts = parentStepId.split("/").filter(Boolean);
    const relativeParts = pathParts.slice(parentParts.length);
    return relativeParts[0] || "default";
  }

  return pathParts[pathParts.length - 1] || "default";
}

function addFieldToGroup(
  groups: Record<string, Record<string, string[]>>,
  sectionKey: string,
  boxKey: string,
  field: string,
) {
  if (!groups[sectionKey]) {
    groups[sectionKey] = {};
  }
  if (!groups[sectionKey][boxKey]) {
    groups[sectionKey][boxKey] = [];
  }
  groups[sectionKey][boxKey].push(field);
}
