import type { UserData } from "~/domains/userData";
import type { FlowController } from "~/services/flow/server/buildFlowController";
import type { SummaryItem } from "~/components/content/summaryOverview/AutoGeneratedSummary";
import type { Translations } from "~/services/translations/getTranslationByKey";
import {
  getFormQuestionsForFields,
  createFieldToStepMapping,
} from "./getFormQuestions";
import type { FlowId } from "~/domains/flowIds";
import { fetchAllFormFields } from "~/services/cms/fetchAllFormFields";
import { groupFieldsByFlowNavigation } from "./groupFieldsBySection";
import { getValidUserDataFields } from "./fieldValidation";
import { expandArrayFields } from "./arrayFieldProcessing";
import { processBoxFields } from "./fieldEntryCreation";
import { parseArrayField } from "./fieldParsingUtils";

function createSummarySection(
  sectionName: string,
  allFields: Array<{
    question: string;
    answer: string;
    editUrl?: string;
    isArrayItem?: boolean;
    arrayIndex?: number;
    arrayBaseField?: string;
    multipleQuestions?: Array<{
      question: string;
      answer: string;
    }>;
  }>,
  sectionTitles: Record<string, string>,
  translations?: Translations,
): SummaryItem {
  // Group array fields by arrayBaseField first, then by arrayIndex
  const arrayFieldsByBase: Record<
    string,
    Record<string, typeof allFields>
  > = {};
  const nonArrayFields: typeof allFields = [];

  for (const field of allFields) {
    if (
      field.isArrayItem &&
      field.arrayBaseField !== undefined &&
      field.arrayIndex !== undefined
    ) {
      const baseFieldName = field.arrayBaseField;
      const groupKey = `${baseFieldName}-${field.arrayIndex}`;

      if (!arrayFieldsByBase[baseFieldName]) {
        arrayFieldsByBase[baseFieldName] = {};
      }
      if (!arrayFieldsByBase[baseFieldName][groupKey]) {
        arrayFieldsByBase[baseFieldName][groupKey] = [];
      }
      arrayFieldsByBase[baseFieldName][groupKey].push(field);
    } else {
      nonArrayFields.push(field);
    }
  }

  // Create array groups for each base field
  const arrayGroups: Array<{
    id: string;
    title: string;
    items: Array<{
      question: string;
      answer: string;
      editUrl?: string;
      multipleQuestions?: Array<{
        question: string;
        answer: string;
      }>;
    }>;
  }> = [];

  for (const [baseFieldName, itemGroups] of Object.entries(arrayFieldsByBase)) {
    const groupItems = [];

    for (const [, groupFields] of Object.entries(itemGroups)) {
      if (groupFields.length > 0) {
        const firstField = groupFields[0];
        const arrayIndex = firstField.arrayIndex || 0;

        // Simple array item numbering (e.g., "Item 1", "Item 2")
        const arrayTitle = `${arrayIndex + 1}`;

        groupItems.push({
          question: arrayTitle,
          answer: "", // Empty for array items
          editUrl: firstField.editUrl,
          multipleQuestions: groupFields.map((field) => ({
            question: field.question,
            answer: field.answer,
          })),
        });
      }
    }

    if (groupItems.length > 0) {
      // Get a human-readable title for the array base field
      const arrayGroupTitle =
        translations?.[baseFieldName] ||
        baseFieldName.charAt(0).toUpperCase() + baseFieldName.slice(1);

      arrayGroups.push({
        id: baseFieldName,
        title: arrayGroupTitle,
        items: groupItems,
      });
    }
  }

  return {
    id: sectionName,
    title:
      sectionTitles[sectionName] ?? translations?.[sectionName] ?? sectionName,
    fields: nonArrayFields,
    arrayGroups: arrayGroups.length > 0 ? arrayGroups : undefined,
  };
}

export async function generateSummaryFromUserData(
  userData: UserData,
  flowId: FlowId,
  flowController?: FlowController,
  translations?: Translations,
): Promise<SummaryItem[]> {
  const userDataFields = getValidUserDataFields(userData);

  if (userDataFields.length === 0) {
    return [];
  }

  const formFieldsMap = await fetchAllFormFields(flowId);
  const fieldToStepMapping = createFieldToStepMapping(formFieldsMap);

  // Expand array fields into individual items
  const expandedFields = expandArrayFields(
    userDataFields,
    userData,
    fieldToStepMapping,
  );

  const filteredFields = expandedFields.filter((field) => {
    if (field.includes(".") && !field.includes("[")) {
      const parentField = field.split(".")[0];
      // If parent exists and is a non-array object, don't render the nested field separately
      const parentValue = userData[parentField];
      if (
        parentValue &&
        typeof parentValue === "object" &&
        !Array.isArray(parentValue)
      ) {
        return false;
      }
    }
    return true;
  });

  const fieldQuestions = await getFormQuestionsForFields(
    filteredFields,
    flowId,
  );

  const groupingResult = flowController
    ? groupFieldsByFlowNavigation(
        filteredFields,
        flowController,
        fieldToStepMapping,
        translations,
      )
    : { groups: {}, sectionTitles: {} };

  const sections: SummaryItem[] = [];

  for (const [sectionName, boxes] of Object.entries(groupingResult.groups)) {
    const allFields: Array<{
      question: string;
      answer: string;
      editUrl?: string;
      isArrayItem?: boolean;
      arrayIndex?: number;
      arrayBaseField?: string;
      multipleQuestions?: Array<{
        question: string;
        answer: string;
      }>;
    }> = [];

    for (const [, fields] of Object.entries(boxes)) {
      const boxFields = processBoxFields(
        fields,
        userData,
        fieldQuestions,
        fieldToStepMapping,
      );

      // Check if these are array fields and add array metadata
      const processedFields = boxFields.map((field, index) => {
        const fieldName = fields[index]; // Use the corresponding field name for this field
        // Handle both "name[index]" and "name[index].subfield" patterns
        const fieldInfo = parseArrayField(fieldName || "");

        if (fieldInfo.isArrayField) {
          const { baseFieldName, arrayIndex } = fieldInfo;

          return {
            ...field,
            isArrayItem: true,
            arrayIndex,
            arrayBaseField: baseFieldName,
          } as const;
        }

        return field;
      });

      allFields.push(...processedFields);
    }

    if (allFields.length === 0) {
      continue;
    }

    const section = createSummarySection(
      sectionName,
      allFields,
      groupingResult.sectionTitles,
      translations,
    );

    sections.push(section);
  }

  return sections;
}
